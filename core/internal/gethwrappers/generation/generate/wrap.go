// package main is a script for generating geth golang contract wrappers for
// solidity artifacts generated by belt.
//
//  Usage:
//
// With core/internal/gethwrappers as your working directory, run
//
//  go run generation/generate/wrap.go <sol-compiler-output-path> <package-name>
//
// This will output the generated file to
// generated/<package-name>/<package-name>.go
//
// See core/internal/gethwrappers/go_generate.go for examples

package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	gethParams "github.com/ethereum/go-ethereum/params"

	"github.com/smartcontractkit/chainlink/core/internal/gethwrappers"
)

func main() {
	beltArtifactPath := os.Args[1] // path to belt artifact to wrap
	pkgName := os.Args[2]          // golang package name for wrapper
	fmt.Println("Generating", pkgName, "contract wrapper")

	contract, err := gethwrappers.ExtractContractDetails(beltArtifactPath)
	if err != nil {
		gethwrappers.Exit("could not get contract details from belt artifact", err)
	}

	className := filepath.Base(beltArtifactPath)
	if !strings.HasSuffix(className, ".json") {
		gethwrappers.Exit("belt artifact path should end with `.json`: "+className,
			nil)
	}
	className = className[:len(className)-len(".json")]
	tmpDir, cleanup := gethwrappers.TempDir(className)
	defer cleanup()
	binPath := filepath.Join(tmpDir, "bin")
	if bErr := ioutil.WriteFile(binPath, []byte(contract.Binary), 0600); bErr != nil {
		gethwrappers.Exit(
			"could not write contract binary to temp working directory", bErr)
	}
	abiPath := filepath.Join(tmpDir, "abi")
	if aErr := ioutil.WriteFile(abiPath, []byte(contract.ABI), 0600); aErr != nil {
		gethwrappers.Exit(
			"could not write contract binary to temp working directory", aErr)
	}
	cwd, err := os.Getwd() // gethwrappers directory
	if err != nil {
		gethwrappers.Exit("could not get working directory", err)
	}
	if filepath.Base(cwd) != "gethwrappers" {
		gethwrappers.Exit("must be run from gethwrappers directory", nil)
	}
	outDir := filepath.Join(cwd, "generated", pkgName)
	if mkdErr := os.MkdirAll(outDir, 0700); err != nil {
		gethwrappers.Exit("failed to create wrapper dir", mkdErr)
	}
	outPath := filepath.Join(outDir, pkgName+".go")

	gethwrappers.Abigen(gethwrappers.AbigenArgs{
		Bin: binPath, ABI: abiPath, Out: outPath, Type: className, Pkg: pkgName,
	})

	// Build succeeded, so update the versions db with the new contract data
	versions, err := gethwrappers.ReadVersionsDB()
	if err != nil {
		gethwrappers.Exit("could not read current versions database", err)
	}
	versions.GethVersion = gethParams.Version
	versions.ContractVersions[pkgName] = gethwrappers.ContractVersion{
		CompilerArtifactPath: beltArtifactPath,
		Hash:                 contract.VersionHash(),
	}
	if err := gethwrappers.WriteVersionsDB(versions); err != nil {
		gethwrappers.Exit("could not save versions db", err)
	}
}
